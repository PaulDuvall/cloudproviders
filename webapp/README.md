# Introduction

This solution fully automates the provisioning of 10 AWS services for deploying a Serverless application. It does this by applying a deployment pipeline as part of a Continuous Deployment process in which every commit is deployed to production if all stages succeed. This approach provides quick and useful feedback between end users and builders.

The application gets data from an Amazon DynamoDB table via Amazon API Gateway and AWS Lambda. You can see this data by accessing a URL generated by API Gateway.

The figure below shows the deployment pipeline provisioned in this solution. 

![CodePipeline](https://github.com/PaulDuvall/cloudproviders/blob/master/webapp/images/codepipeline.png)

The figure below shows the data returned when accessing the URL generated by API Gateway.

<img src="https://github.com/PaulDuvall/cloudproviders/blob/master/webapp/images/api-gateway-results.png" height="400" />

## Continuous Delivery Benefits
Continuous Delivery is the full automation of your release process in which your software is always in a releaseable state. With every code change, a deployment pipeline builds, tests, deploys, and makes the software available to release to users. If anything fails, the deployment pipeline will stop and notify builders so that they can quickly commit changes to source control to fix the problem. 

The major benefit of Continuous Delivery is that you can get useful and frequent feedback on which to build better software for users.

Continuous Delivery is part of set of practices for modern application development. The illustration below shows the difference between some of these modern practices such as continuous integration, continuous delivery, and continuous deployment.

![CI and CD](https://d1.awsstatic.com/product-marketing/DevOps/continuous_delivery.4f4cddb8556e2b1a0ca0872ace4d5fe2f68bbc58.png) (Source: https://aws.amazon.com/devops/continuous-delivery/)

Continuous Integration focuses on getting extremely quick and useful feedback to builders by running a build, static analysis, and unit tests in a development environment with every code change committed to source control. 

Continuous Delivery assumes that good Continuous Integration practices are present and extends the pipeline to deploying changes to environments that are more like production. Longer-running tests are executed in these environments and the environments themselves are provisioned and configured based on a fully automated process. The very last part of a Continuous Delivery process is a human decision to release the software by clicking a button. This might include various approvals in an automated process.

Continuous Deployment extends on Continuous Delivery. The only - but very critical - difference is that with Continuous Deployment, changes are automatically deployed to production environments if all of the builds, tests, deployments, and other checks pass. 

## Serverless Benefits
Here are some of key aspects with serverless on AWS.

* **No infrastructure provisioning or management** - The infrastructure provider (i.e. AWS) manages the technical operations such as monitoring, scaling, and security.
* **Automatic scaling** - Serverless services can scale based on demand without any additional changes.
* **Pay for value** - Pay only for what you use (i.e. do not pay for "idle"). This often leads to lower costs
* **Highly available and secure** - The services build in the redundancies so that builders (and end users) are less likely to experience downtime. Things like automatic patching occur without any changes or notice on behalf of builders.

All of this means is that - as a builder - you are able to provide more value to customers. This is because you are spending less time on infrastructure and more time on coding and experimenting for end users.  

## Automated Solution Instructions

With this automated solution, you will run a single command to launch a CloudFormation Stack that provisions all of the resources in this solution. Then, you will go to your web browser to see the data returned from an Amazon DynamoDB table via Amazon API Gateway and AWS Lambda. 

### Prerequisites
* [AWS Account and permissions](https://github.com/PaulDuvall/aws-encryption-workshop/wiki/0.2#create-or-access-an-aws-account-and-grant-iam-privileges) for the required AWS services.
* [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html) installed and access keys configured.
* While most IDEs should work, only [AWS Cloud9](https://github.com/PaulDuvall/aws-encryption-workshop/wiki/0.2#setup-aws-cloud9) is supported for this solution. Git is automatically installed with Cloud9.

### Launch CloudFormation Stack

Run the commands below to launch the CloudFormation Stack that provisions all the AWS resources in this solution.

1. `git clone https://github.com/PaulDuvall/cloudproviders.git`
1. `cd cloudproviders`
1. Run this command: `sudo chmod +x launch-stack.sh` 
1.  Run this command: `./launch-stack.sh`. It will take a few minutes to initiate the launch of the stack and then another five minutes to launch all the resources. Once the **pmd-serverless-app-us-east-1** stack is complete, continue to the next [step](#get-data-from-api-through-browser) to get the data.

### Get Data from API through Browser

1. Once the **serverless-app-us-east-1** [CloudFormation stack](https://console.aws.amazon.com/cloudformation/home/) is complete, click on the **Outputs** pane.
2. Click on the URL in the **Value** column for the *GetDataApi* Key.
3. Three rows of data are returned. This data is pulled from the [DynamoDB table](https://console.aws.amazon.com/dynamodb/home?region=us-east-1#tables:selected=CloudProviders;tab=items) via AWS [API Gateway](https://console.aws.amazon.com/apigateway/) and [AWS Lambda](https://console.aws.amazon.com/lambda/home?region=us-east-1#/functions/LambdaGetDynamoDB). 

### Architecture and Workflow

As a user, when you click on the URL provided as a CloudFormation Stack Output that is generated by API Gateway, it accesses API Gateway which is configured to trigger an AWS Lambda Function. This function retrieves the data from a DynamoDB table and sends the response back trhough API Gateway so that users get a list of data stored in the DynamoDB table.

You can see this workflow in the image below.

![Solution Workflow](https://github.com/PaulDuvall/cloudproviders/blob/master/webapp/images/serverlessapp-workflow.png)

As an engineer, you will run a simple AWS CLI command to launch the CloudFormation Stack from the CloudFormation template. This stack automatically provisions storing files, storing code, running builds, and orchestrating the deployment pipeline of the key solution resources.

The deployment pipeline automatically provisioned by the CloudFormation stack is defined in AWS CodePipeline. This pipeline has a CodeCommit repository for storing code, a couple of CodeBuild projects for building AWS Lambda functions, and CloudFormation Deploy Providers that deploy the Serverless resources using the AWS Serverless Application Model (SAM). 

The AWS SAM is a Serverless Domain Specfic Language (DSL) resources based on CloudFormation. The purpose of AWS SAM is to build serverless applications in simple and clean syntax (i.e. much less configuration code). In this solution, the SAM template generates API Gateway, Lambda, and DynamoDB.

All of the resources in this solution are defined in greater detail below. 

You can see this architecture in the image below.

![Solution Architecture](https://diagrams-pmd-sitebucket-n0b3ceywwbxz.s3.amazonaws.com/serverless_web_apps.png)


#### CloudFormation Stack

* **Amazon S3** - S3 is used to store files. In this solution, I am using S3 to store the source files that populate the CodeCode repository, store the artifacts used by CodePipeline, and store the files used by the static website. The CloudFormation template defines this using the [AWS::S3::Bucket](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-s3-bucket.html) resource. 
* **AWS IAM** - IAM is used to define permissions to AWS resources. In this solution, I am using IAM to define roles for access to CodePipeline, CodeBuild, and the CloudFormation deployment resource. The CloudFormation template defines this using the [AWS::IAM::Role](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-iam-role.html) resource.
* **AWS CodeCommit** - CodeCommit is a managed Git repository for storing source code and related files. In this solution, I am populating the CodeCommit repo with source files stored in S3 (based on the [cloudproviders](https://github.com/PaulDuvall/cloudproviders/) GitHub repo). The CloudFormation template defines this using the [AWS::CodeCommit::Repository](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codecommit-repository.html) resource.
* **AWS CodeBuild** - A managed service for rnning builds and tests or anything else you might run from a command line. In this solution, I am using CodeBuild to build two Lambda functions. One for getting data from a DynamoDB table and the other for posting data to this table. The CloudFormation template defines this using the [AWS::CodeBuild::Project](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource.
* **AWS CodePipeline** - A managed service for orchestrating a software delivery workflow. In this solution, I am using CodePipeline to get source files from CodeCommit, build Lambda functions, and deploy them via CloudFormation. The CloudFormation template defines CodePipeline using the [AWS::CodePipeline::Pipeline](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-codebuild-project.html) resource.

#### CodePipeline Deployment Pipeline

Here are the key components of the deployment pipeline defined in AWS CodePipeline. This pipeline is provisioned by the CloudFormation Stack that you launched. CodePipeline manages the continuous deployment capability for this serverless application. 

* **AWS CodeCommit** - This is the Git repository that contains the Lambda functions, SAM template, and other files that are deployed on AWS.
* **AWS CodeBuild** - Builds the Lambda functions by using [aws cloudformation](https://docs.aws.amazon.com/cli/latest/reference/cloudformation/package.html) to generate the CloudFormation template. Another CodeBuild project runs the AWS CLI [command](https://docs.aws.amazon.com/cli/latest/reference/dynamodb/batch-write-item.html) to insert data into the DynamoDB table as the last action in the pipeline. 
* **AWS CloudFormation** - The CloudFormation deploy provider generates a Change Set and then deploys the Lambda functions onto the AWS Lambda service. 

#### Serverless Application Model Stack

The AWS Serverless Application Model stack is launched by the CloudFormation deploy provider in CodePipeline. SAM provides that abstraction layer on top of CloudFormation that can also include CloudFormation resources. The CloudFormation deploy provider in CodePipeline is defined to call [sam-http.yml](https://github.com/PaulDuvall/cloudproviders/blob/master/webapp/sam-http.yml). The template creates a CloudFormation stack that provisions a DynamoDB table, two Lambda functions, IAM permissions, and an API Gateway. 

* **Amazon DynamoDB** - Defines a DynamoDB table for storing information about cloud providers. 
* **AWS Lambda** - Two Lambda functions are defined in Node.js. One of these functions gets data from the DynamoDB table and the other posts data to this table. 
* **Amazon API Gateway** - Create HTTP APIs and connect to different services. I am using the [HTTP API](https://aws.amazon.com/blogs/compute/announcing-http-apis-for-amazon-api-gateway/) feature to provide the "front door" to the data stored in the DynamoDB table. 
* **AWS IAM** - In the context of SAM, you often only need to define managed policies rather than defining detailed IAM permissions as you might do in CloudFormation. For example, I am using the DynamoDBReadPolicy and  
DynamoDBWritePolicy [managed policies](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-policy-template-list.html) to define permissions for the DynamoDB table.

[Manual Instructions](https://github.com/PaulDuvall/cloudproviders/wiki/Manual-Instructions)